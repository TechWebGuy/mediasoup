'use strict';

const EventEmitter = require('events').EventEmitter;
const sdpTransform = require('sdp-transform');
const randomString = require('random-string');
const logger = require('../../logger');
const extra = require('../../extra');
const InvalidStateError = require('../../errors').InvalidStateError;
const RTCDictionaries = require('../RTCDictionaries');
const RTCSessionDescription = require('../RTCSessionDescription');
const common = require('./common');

const NEGOTIATION_NEEDED_DELAY = 1000;
const KIND_TO_MID =
{
	audio : 'audio-tracks',
	video : 'video-tracks'
};

class RTCPeerConnectionPlanB extends EventEmitter
{
	constructor(options)
	{
		super();
		this.setMaxListeners(Infinity);

		this._logger = logger(`webrtc:RTCPeerConnectionPlanB:${options.peer.name}`);
		this._logger.debug('constructor() [options:%o]', options);

		// Options.
		this._options = options;

		// Peer instance.
		this._peer = options.peer;

		// Local RTCSessionDescription.
		this._localDescription = null;

		// Remote RTCSessionDescription.
		this._remoteDescription = null;

		// Initial signaling state.
		this._signalingState = RTCDictionaries.RTCSignalingState.stable;

		// Busy flag.
		this._busy = false;

		// Negotiation needed flag.
		this._negotiationNeeded = false;

		// Negotiation timer to collect them all.
		this._negotiationNeededTimer = null;

		// SDP global fields.
		this._sdpGlobalFields =
		{
			id      : randomString({ letters: false, length: 16 }),
			version : 0
		};

		// Handle peer 'close' event.
		this._peer.on('close', (error) =>
		{
			this.emit('close', error);
		});
	}

	get closed()
	{
		return this._peer.closed;
	}

	get peer()
	{
		return this._peer;
	}

	get localDescription()
	{
		return this._localDescription;
	}

	get remoteDescription()
	{
		return this._remoteDescription;
	}

	get signalingState()
	{
		return this._signalingState;
	}

	close()
	{
		this._logger.debug('close()');

		// Cancel the negotiation timer.
		clearTimeout(this._negotiationNeededTimer);

		this._peer.close();
	}

	/**
	 * Set the peer's capabilities.
	 * @param {string} sdp - SDP offer generated by the remote peer.
	 */
	setCapabilities(sdp)
	{
		this._logger.debug('setCapabilities()');

		if (this.closed)
			throw new InvalidStateError('closed');

		if (this._peer.capabilities)
			throw new InvalidStateError('capabilities are ready set');

		let desc;

		try
		{
			desc = new RTCSessionDescription({ type: 'offer', sdp: sdp });
		}
		catch (error)
		{
			return Promise.reject(new Error(`invalid capabilities SDP: ${error}`));
		}

		// Set busy flag.
		this._busy = true;

		// Return a promise that resolves when everything is done.
		return Promise.resolve()
			// First set peer capabilities.
			.then(() =>
			{
				let capabilities = common.descToCapabilities(desc.parsed);

				return this._peer.setCapabilities(capabilities);
			})
			// Then create a Transport instance.
			.then(() =>
			{
				return this._peer.createTransport(this._options.transportOptions);
			})
			.then(() =>
			{
				this._logger.debug('setCapabilities() | succeed');

				// Unset busy flag.
				this._busy = false;
			})
			.catch((error) =>
			{
				this._logger.error('setCapabilities() | failed: %s', error);

				// Unset busy flag.
				this._busy = false;

				throw error;
			});
	}

	createOffer()
	{
		this._logger.debug('createOffer()');

		if (this._busy)
			return Promise.reject(new InvalidStateError('busy'));

		if (!this._peer.capabilities)
			return Promise.reject(new InvalidStateError('capabilities not yet set'));

		if (this._signalingState !== RTCDictionaries.RTCSignalingState.stable)
		{
			return Promise.reject(new InvalidStateError(`invalid signaling state [signalingState:${this._signalingState}]`));
		}

		// Set busy flag.
		this._busy = true;

		// Return a promise that resolves when everything is done.
		return Promise.resolve()
			// First handle all the RtpSenders.
			.then(() =>
			{
				let transport = this._peer.transports[0];
				let promises = [];

				// Inspect the already existing RtpSenders and handle them.
				for (let rtpSender of this._peer.rtpSenders)
				{
					// Ignore if it already has a transport (so it was already handled).
					// TODO: I don't like this. It's better to handle my own set of
					// handled RtpSenders.
					if (rtpSender.transport)
						continue;

					let promise = rtpSender.setTransport(transport)
						.then(() =>
						{
							rtpSender.on('close', () =>
							{
								this._logger.debug('rtpSender "close" event');

								// Set flag.
								this._negotiationNeeded = true;

								// Try to renegotiate.
								this._mayRenegotiate();
							});

							rtpSender.on('parameterschange', () =>
							{
								this._logger.debug('rtpSender "parameterschange" event');

								// Set flag.
								this._negotiationNeeded = true;

								// Try to renegotiate.
								this._mayRenegotiate();
							});
						});

					promises.push(promise);
				}

				return Promise.all(promises);
			})
			.then(() =>
			{
				this._logger.debug('createOffer() | succeed');

				// Unset busy flag.
				this._busy = false;

				// Create an offer.
				let localDescription = this._createLocalDescription('offer');

				// Resolve with it.
				return Promise.resolve(localDescription);
			})
			.catch((error) =>
			{
				this._logger.error('createOffer() | failed: %s', error);

				// Unset busy flag.
				this._busy = false;

				throw error;
			});
	}

	createAnswer()
	{
		this._logger.debug('createAnswer()');

		if (this._busy)
			return Promise.reject(new InvalidStateError('busy'));

		if (this._signalingState !== RTCDictionaries.RTCSignalingState.haveRemoteOffer)
		{
			return Promise.reject(new InvalidStateError(`invalid signaling state [signalingState:${this._signalingState}]`));
		}

		// Create an answer.
		let localDescription = this._createLocalDescription('answer');

		// Resolve with it.
		return Promise.resolve(localDescription);
	}

	/**
	 * NOTE: This method assumes that the given desc is the one previously
	 * created by createOffer() or createAnswer().
	 */
	setLocalDescription(desc)
	{
		this._logger.debug('setLocalDescription()');

		if (this._busy)
			return Promise.reject(new InvalidStateError('busy'));

		if (!this._peer.capabilities)
			return Promise.reject(new InvalidStateError('capabilities not yet set'));

		let remoteDescription = desc;
		let newSignalingState;

		switch (remoteDescription.type)
		{
			case 'offer':
			{
				if (this._signalingState !== RTCDictionaries.RTCSignalingState.stable)
					return Promise.reject(new InvalidStateError(`invalid RTCSessionDescription.type [type:${remoteDescription.type}, signalingState:${this._signalingState}]`));

				newSignalingState = RTCDictionaries.RTCSignalingState.haveLocalOffer;

				break;
			}

			case 'answer':
			{
				if (this._signalingState !== RTCDictionaries.RTCSignalingState.haveRemoteOffer)
					return Promise.reject(new InvalidStateError(`invalid RTCSessionDescription.type [type:${remoteDescription.type}, signalingState:${this._signalingState}]`));

				newSignalingState = RTCDictionaries.RTCSignalingState.stable;

				break;
			}

			default:
			{
				return Promise.reject(new Error(`invalid RTCSessionDescription.type [type:${remoteDescription.type}]`));
			}
		}

		// Update the local description.
		this._localDescription = desc;

		// Update signaling state.
		this._setSignalingState(newSignalingState);

		// Resolve.
		return Promise.resolve();
	}

	setRemoteDescription(desc)
	{
		this._logger.debug('setRemoteDescription()');

		if (this._busy)
			return Promise.reject(new InvalidStateError('busy'));

		if (!this._peer.capabilities)
			return Promise.reject(new InvalidStateError('capabilities not yet set'));

		let remoteDescription;

		try
		{
			remoteDescription = new RTCSessionDescription(desc);
		}
		catch (error)
		{
			return Promise.reject(new Error(`invalid RTCSessionDescriptionInit: ${error}`));
		}

		switch (remoteDescription.type)
		{
			case 'offer':
			{
				if (this._signalingState !== RTCDictionaries.RTCSignalingState.stable)
				{
					return Promise.reject(new InvalidStateError(`invalid RTCSessionDescription.type [type:${remoteDescription.type}, signalingState:${this._signalingState}]`));
				}

				// Initial offer received from the client.
				if (!this._remoteDescription)
				{
					return Promise.reject(new Error('initial offer from the endpoint not supported'));
				}
				// Re-offer received from the client.
				else
				{
					return this._setRemoteReOffer(remoteDescription);
				}
			}

			case 'answer':
			{
				if (this._signalingState !== RTCDictionaries.RTCSignalingState.haveLocalOffer)
				{
					return Promise.reject(new InvalidStateError(`invalid RTCSessionDescription.type [type:${remoteDescription.type}, signalingState:${this._signalingState}]`));
				}

				// Initial answer received from the client.
				if (!this._remoteDescription)
				{
					return this._setRemoteInitialAnswer(remoteDescription);
				}
				// Re-answer received from the client.
				else
				{
					return this._setRemoteReAnswer(remoteDescription);
				}
			}

			default:
			{
				return Promise.reject(new Error(`invalid RTCSessionDescription.type [type:${remoteDescription.type}]`));
			}
		}
	}

	_setRemoteReOffer(remoteDescription) // eslint-disable-line no-unused-vars
	{
		this._logger.debug('_setRemoteReOffer()');

		// TODO: Do it.

		return Promise.reject(new Error('renegotiation initiated by the endpoint not yet supported'));
	}

	_setRemoteInitialAnswer(remoteDescription)
	{
		this._logger.debug('_setRemoteInitialAnswer()');

		let self = this;
		let parsed = remoteDescription.parsed;
		let transport = this._peer.transports[0];

		// Set busy flag.
		this._busy = true;

		// Return a promise that resolves when everything is done.
		return Promise.resolve()
		// First sets the DTLS remote parameters into our local transport.
			.then(() =>
			{
				let remoteDtlsParameters = common.descToRemoteDtlsParameters(parsed);

				return transport.setRemoteDtlsParameters(remoteDtlsParameters);
			})
			// Then create the corresponding RtpReceivers.
			.then(() =>
			{
				let promises = [];

				for (let parsedMedia of parsed.media)
				{
					// If the answer has RTX or FEC it will have a=ssrc-group attribute(s)
					// so media SSRC is the first value on it. Example:
					//   a=ssrc-group:FID 369944027 1319041533
					//   => media ssrc = 369944027
					//
					//   Otherwise (no RTX/FEC) each a=ssrc means a sending MediaStreamTrack.
					//
					if (Array.isArray(parsedMedia.ssrcGroups))
					{
						for (let ssrcGroup of parsedMedia.ssrcGroups)
						{
							let mediaSsrc = Number(ssrcGroup.ssrcs.split(' ')[0]);
							let promise = createRtpReceiverForSsrc(mediaSsrc, parsedMedia);

							promises.push(promise);
						}
					}
					else if (Array.isArray(parsedMedia.ssrcs))
					{
						let mediaSsrcs = new Set();

						for (let ssrcObj of parsedMedia.ssrcs)
						{
							let mediaSsrc = ssrcObj.id;
							let promise;

							if (mediaSsrcs.has(mediaSsrc))
								continue;

							mediaSsrcs.add(mediaSsrc);
							promise = createRtpReceiverForSsrc(mediaSsrc, parsedMedia);
							promises.push(promise);
						}
					}
				}

				return Promise.all(promises);
			})
			.then(() =>
			{
				this._logger.debug('_setRemoteInitialAnswer() | succeed');

				// Unset busy flag.
				this._busy = false;

				// Set remote description.
				this._remoteDescription = remoteDescription;

				// Update signaling state.
				this._setSignalingState(RTCDictionaries.RTCSignalingState.stable);

				// Handle peer 'newrtpsender' event once first SDP O/A is done.
				this._peer.on('newrtpsender', () =>
				{
					this._logger.debug('peer "newrtpsender" event');

					// Set flag.
					this._negotiationNeeded = true;

					// Try to renegotiate.
					this._mayRenegotiate();
				});
			})
			.catch((error) =>
			{
				this._logger.error('_setRemoteInitialAnswer() | failed: %s', error);

				// Unset busy flag.
				this._busy = false;

				throw error;
			});

		function createRtpReceiverForSsrc(mediaSsrc, parsedMedia)
		{
			// TODO: We assume no RTX/FEC in client's generated answer.

			let kind = parsedMedia.type;
			// Map of RtpCodecParameters indexed by payload type.
			let mapCodecs = new Map();

			for (let rtp of parsedMedia.rtp)
			{
				// TODO: This will fail for kind:depth and video/vp8.
				let codecMime = kind + '/' + rtp.codec;
				let codec =
				{
					name         : codecMime,
					payloadType  : rtp.payload,
					clockRate    : rtp.rate,
					rtcpFeedback : [],
					parameters   : {}
				};

				if (rtp.encoding > 1)
					codec.numChannels = rtp.encoding;

				mapCodecs.set(rtp.payload, codec);
			}

			if (parsedMedia.fmtp)
			{
				for (let fmtp of parsedMedia.fmtp)
				{
					let params = sdpTransform.parseFmtpConfig(fmtp.config);
					let codec = mapCodecs.get(fmtp.payload);

					if (!codec)
						continue;

					for (let key of Object.keys(params))
					{
						let normalizedKey = extra.paramFromSDP(key);

						codec.parameters[normalizedKey] = params[key];
					}
				}
			}

			if (parsedMedia.rtcpFb)
			{
				for (let fb of parsedMedia.rtcpFb)
				{
					let codec = mapCodecs.get(fb.payload);

					if (!codec)
						continue;

					codec.rtcpFeedback.push(
						{
							type      : fb.type,
							parameter : fb.subtype
						});
				}
			}

			// Array of RtpEncodingParameters.
			// NOTE: Just a single encoding will be created with the first media codec
			// in the answer.
			let encodings =
			[
				{
					ssrc             : mediaSsrc,
					codecPayloadType : mapCodecs.values().next().value.payloadType
				}
			];

			// Array of RtpHeaderExtensionParameters.
			let headerExtensions = [];

			if (Array.isArray(parsedMedia.ext))
			{
				for (let ext of parsedMedia.ext)
				{
					let id = ext.value;
					let uri = ext.uri;

					// TODO: Hack for https://github.com/clux/sdp-transform/issues/51
					if (typeof id !== 'number')
						id = parseInt(id);

					headerExtensions.push(
						{
							uri : uri,
							id  : id
						});
				}
			}

			let cname;
			let msid;

			for (let ssrc of parsedMedia.ssrcs)
			{
				if (ssrc.id !== mediaSsrc)
					continue;

				switch (ssrc.attribute)
				{
					case 'cname':
						cname = ssrc.value;
						break;

					// Chrome uses:
					//   a=ssrc:xxxx msid:yyyy zzzz
					//   a=ssrc:xxxx mslabel:yyyy
					//   a=ssrc:xxxx label:zzzz
					// Where yyyy is the MediaStream.id and zzzz the MediaStreamTrack.id.
					case 'msid':
						msid = ssrc.value;
						break;
				}
			}

			// Create a RtpReceiver.
			let rtpReceiver = self._peer.RtpReceiver(kind, transport);

			// RtpParameters object.
			let rtpParameters =
			{
				muxId            : parsedMedia.mid,
				codecs           : Array.from(mapCodecs.values()),
				encodings        : encodings,
				headerExtensions : headerExtensions,
				rtcp             :
				{
					cname : cname
				},
				userParameters   :
				{
					msid : msid
				}
			};

			// TODO: REMOVE
			// self._logger.warn('------ calling rtpReceiver.receive() with\n%s', JSON.stringify(rtpParameters, null, '\t'));

			// Tell the RtpReceiver to receive and return the Promise.
			return rtpReceiver.receive(rtpParameters);
		}
	}

	_setRemoteReAnswer(remoteDescription)
	{
		this._logger.debug('_setRemoteReAnswer()');

		// Set remote description.
		this._remoteDescription = remoteDescription;

		// Update signaling state.
		this._setSignalingState(RTCDictionaries.RTCSignalingState.stable);

		return Promise.resolve();
	}

	_setSignalingState(signalingState)
	{
		this._logger.debug('_setSignalingState() [signalingState:%s]', signalingState);

		if (this._signalingState === signalingState)
			return;

		this._signalingState = signalingState;

		// Emit 'signalingstatechange'.
		this.emit('signalingstatechange');

		// Things may have happened while busy, so check it.
		if (this._signalingState === RTCDictionaries.RTCSignalingState.stable)
		{
			process.nextTick(() =>
			{
				this._mayRenegotiate();
			});
		}
	}

	_mayRenegotiate()
	{
		// If already scheduled, ignore.
		if (this._negotiationNeededTimer)
			return;

		// If busy, ignore.
		if (this._busy)
			return;

		// Ignore if capabilities are not yet set.
		if (!this._peer.capabilities)
			return;

		// Ignore if signalingState is not 'stable'.
		if (this._signalingState !== RTCDictionaries.RTCSignalingState.stable)
			return;

		// Schedule the task.
		this._negotiationNeededTimer = setTimeout(() =>
		{
			this._negotiationNeededTimer = null;

			// Ignore if closed.
			if (this.closed)
				return;

			// If busy, ignore.
			if (this._busy)
				return;

			if (this._negotiationNeeded)
			{
				// Reset flag.
				this._negotiationNeeded = false;

				// Emit event.
				this.emit('negotiationneeded');
			}
		}, NEGOTIATION_NEEDED_DELAY);
	}

	_createLocalDescription(type)
	{
		this._logger.debug('_createLocalDescription() [type:%s]', type);

		let self = this;
		let obj = {};
		let sdpVersion = this._sdpGlobalFields.version;
		let kinds = Object.keys(KIND_TO_MID);
		let capabilities = this._peer.capabilities;
		let transport = this._peer.transports[0];

		// Increase SDP version if an offer.
		if (type === 'offer')
			sdpVersion++;

		obj.version = 0;
		obj.origin =
		{
			address        : '0.0.0.0',
			ipVer          : 4,
			netType        : 'IN',
			sessionId      : this._sdpGlobalFields.id,
			sessionVersion : sdpVersion,
			username       : 'mediasoup'
		};
		obj.name = '-';
		obj.timing = { start: 0, stop: 0 };
		obj.icelite = 'ice-lite'; // Important.
		obj.msidSemantic =
		{
			semantic : 'WMS',
			token    : '*'
		};
		obj.groups =
		[
			{
				type : 'BUNDLE',
				mids : kinds.map((k) => KIND_TO_MID[k]).join(' ')
			}
		];
		obj.media = [];

		// DTLS fingerprint.
		obj.fingerprint =
		{
			type : 'sha-256',
			hash : extra.fingerprintToSDP(transport.dtlsLocalParameters.fingerprints['sha-256'])
		};

		// Create a SDP media section for each media kind.
		for (let kind of kinds)
		{
			addMediaSection(kind);
		}

		// Create local RTCSessionDescription.
		let localDescription = new RTCSessionDescription(
			{
				type : type,
				sdp  : obj
			});

		return localDescription;

		function addMediaSection(kind)
		{
			let objMedia = {};

			// m= line.
			objMedia.type = kind;
			objMedia.port = 7;
			objMedia.protocol = 'RTP/SAVPF';

			// c= line.
			objMedia.connection = { ip: '127.0.0.1', version: 4 };

			// a=mid attribute.
			objMedia.mid = KIND_TO_MID[kind];

			// ICE.
			objMedia.iceUfrag = transport.iceLocalParameters.usernameFragment;
			objMedia.icePwd = transport.iceLocalParameters.password;
			objMedia.candidates = [];

			for (let candidate of transport.iceLocalCandidates)
			{
				let objCandidate = {};

				// mediasoup does not support non rtcp-mux so candidates component is
				// always RTP (1).
				objCandidate.component = 1;
				objCandidate.foundation = candidate.foundation;
				objCandidate.ip = candidate.ip;
				objCandidate.port = candidate.port;
				objCandidate.priority = candidate.priority;
				objCandidate.transport = candidate.protocol;
				objCandidate.type = candidate.type;
				if (candidate.tcpType)
					objCandidate.tcpType = candidate.tcpType;

				objMedia.candidates.push(objCandidate);
			}

			// DTLS.
			// If 'offer' always use 'actpass'.
			if (type === 'offer')
				objMedia.setup = 'actpass';
			else
				objMedia.setup = transport.dtlsLocalParameters.role === 'client' ? 'active' : 'passive';

			// a=direction attribute.
			// TODO: Always?
			objMedia.direction = 'sendrecv';

			objMedia.rtp = [];
			objMedia.rtcpFb = [];
			objMedia.fmtp = [];

			// Array of payload types.
			let payloads = [];

			// Codecs.
			for (let codec of capabilities.codecs)
			{
				if (codec.kind && codec.kind !== kind)
					continue;

				payloads.push(codec.payloadType);

				let codecSubtype = codec.name.split('/')[1];
				let rtp =
				{
					payload : codec.payloadType,
					codec   : codecSubtype,
					rate    : codec.clockRate
				};

				if (codec.numChannels > 1)
					rtp.encoding = codec.numChannels;

				objMedia.rtp.push(rtp);

				// If codec has parameters add them into a=fmtp attributes.
				if (codec.parameters)
				{
					let paramFmtp =
					{
						payload : codec.payloadType,
						config  : ''
					};

					for (let key of Object.keys(codec.parameters))
					{
						let normalizedKey = extra.paramToSDP(key);

						if (paramFmtp.config)
							paramFmtp.config += ';';
						paramFmtp.config += `${normalizedKey}=${codec.parameters[key]}`;
					}

					if (paramFmtp.config)
						objMedia.fmtp.push(paramFmtp);
				}

				// Set RTCP feedback.
				if (codec.rtcpFeedback)
				{
					for (let fb of codec.rtcpFeedback)
					{
						objMedia.rtcpFb.push(
							{
								payload : codec.payloadType,
								type    : fb.type,
								subtype : fb.parameter
							});
					}
				}
			}

			// Codec payloads.
			objMedia.payloads = payloads.join(' ');

			// SSRCs.
			objMedia.ssrcs = [];

			for (let rtpSender of self._peer.rtpSenders)
			{
				if (rtpSender.kind !== kind)
					continue;

				for (let encoding of rtpSender.rtpParameters.encodings)
				{
					objMedia.ssrcs.push(
						{
							id        : encoding.ssrc,
							attribute : 'cname',
							value     : rtpSender.rtpParameters.rtcp.cname
						});

					objMedia.ssrcs.push(
						{
							id        : encoding.ssrc,
							attribute : 'msid',
							value     : rtpSender.rtpParameters.userParameters.msid
						});
				}
			}

			// RTP header extensions.
			objMedia.ext = [];

			for (let headerExtension of capabilities.headerExtensions)
			{
				if (headerExtension.kind && headerExtension.kind !== kind)
					continue;

				objMedia.ext.push(
					{
						value : headerExtension.preferredId,
						uri   : headerExtension.uri
					});
			}

			// a=rtcp-mux attribute.
			objMedia.rtcpMux = 'rtcp-mux';

			// Bandwidth.
			if (self._options.bandwidth && self._options.bandwidth[kind])
			{
				objMedia.bandwidth =
				[
					{ type: 'AS', limit : self._options.bandwidth[kind] }
				];
			}

			// Add the media section.
			obj.media.push(objMedia);
		}
	}
}

module.exports = RTCPeerConnectionPlanB;
